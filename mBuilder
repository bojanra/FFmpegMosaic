#!/usr/bin/perl -w

=head1 NAME

mBuilder - Build ffmpeg commandline string to produce a video mosaic

=head1 SYNOPSIS

 mBuilder [options] configuration_file 

=head1 OPTIONS

 -h         show this help
 -c         only validate config file

=head1 DESCRIPTION

mBuilder uses input file in YAML format and generates output string fir ffmpeg to 
generate such an output.

 If no configuration file is found, mBuilder will use mosaic.yaml

Please install:
 libsmart-comments-perl libbareword-filehandles-perl libindirect-perl libmultidimensional-perl libstrictures-perl

=cut

=head1 AUTHOR

Copyright (C) Bojan Ramsak 2019

All rights reserved

=cut

use 5.010;
use warnings;
use strict;
use utf8;
use Pod::Usage;
use Getopt::Std;
use lib './lib/';
use Mosaic;
use YAML::XS;
use Try::Tiny;
use Smart::Comments;
use open qw ( :std :encoding(UTF-8));

our $VERSION = '0.11';

my %args;

getopts( "hc", \%args );

say("mBuilder - ver. $VERSION Copyright 2019 Bojan Ramšak");

pod2usage(
    -verbose  => 99,
    -exitval  => 0,
    -sections => "SYNOPSIS|OPTIONS|DESCRIPTION"
    )
    if exists $args{h};

my $configFile = shift(@ARGV) // "mosaic.yaml";

### using configfile: $configFile

my $app = Mosaic->new( configFile => $configFile );

if ( !$app->validateConfig() ) {
    say("Configuration invalid");
    exit(1);
}

say( $app->report() );

if ( exists $args{c} ) {
    # just validate
    exit;
} else {
    say( $app->buildCmd() );
    exit
}

__END__

sub BUILD {
    my ($self) = @_;

    $self->{status} = {
        count => 0,
        last  => localtime(0)->datetime,
    };
    $self->{RTCUpdateTimer} = undef;

    return;
} ## end sub BUILD

=head3 run ( )

 Resolve coder hostname list to IP and build new hash.

=cut

sub resolveCoder {
    my ($self) = @_;

    my $coder = {};

    #TODO
#    socket( UDPPORT, PF_INET, SOCK_DGRAM, getprotobyname("udp") );

    foreach my $hostname ( keys %{ $self->config->{coder} } ) {
        my $address = inet_aton($hostname);
        my $ip;
        if ($address) {
            $ip                       = inet_ntoa($address);
            $coder->{$hostname}{ip}   = $ip;
            $coder->{$hostname}{addr} = $address;
            $coder->{$hostname}{tag}  = $self->config->{coder}{$hostname} // '';
        } else {
            $self->{log}->error("hostname resolving: $hostname");
            return;
        }
    } ## end foreach my $hostname ( keys...)

    $self->{log}->debug( "valid coders with IP in list: " . scalar( keys(%$coder) ) );
    $self->{coder} = $coder;
    return 1;
} ## end sub resolveCoder

sub start {
    my ($self) = @_;

    if ( !$self->resolveCoder() ) {
        exit 1;
    }

    # initialize socket for UDP sending
    if ( !socket( UDPPORT, PF_INET, SOCK_DGRAM, getprotobyname("udp") ) ) {
        $self->{log}->fatal("connecting UDP socket");
        exit 1;
    }

    binmode(UDPPORT);

    $self->addConsumer(
        sub {
            my ($response) = @_;

            for ( $response->{method} ) {
                /dynamic/ && exists $response->{param}{label} && do {
                    $self->radioText($response);
                    return;
                };
                /ta/ && do {
                    $self->trafficAnnouncement($response);
                    return;
                };
                /tmc/ && do {
                    $self->tmcData($response);
                    return;
                };
            } ## end for ( $response->{method...})
        },
        'rds'
    );

    $self->launchRTCUpdater();

    ### start the app by connecting to RabbitMQ
    # all other connections are launched after established connection to RMQ - onReady
    # because of using notify
    $self->connect();
    return;
} ## end sub start

sub onReady {
    my ($self) = @_;

    # now we are ready to respond to commands
    my $info = {
        method => 'ready',
        param  => 'mBuilder'
    };
    $self->publish( $info, 'ctrl' );
    return;
} ## end sub onReady

=head3 onCommand ( )

 This subroutine is called whenever a "ctrl" request is received from RMQ

=cut

sub onCommand {
    my ( $self, $info ) = @_;
    my $method = $info->{method};

    if ( $method eq "get" ) {
        return { mBuilder => $self->getStatus() };
    } else {
        return;
    }
} ## end sub onCommand

=head3 getStatus ( )

Return current daemon status.

=cut

sub getStatus {
    my ($self) = @_;

    return $self->{status};
}

=head3 launchRTCUpdater( )

 Send current RTC all RDS coders. Take also care of summer/winter time CEST/CET.

=cut

sub launchRTCUpdater {
    my ($self) = @_;

    $self->{RTCUpdateTimer} = AnyEvent->timer(
        after    => 3,
        interval => 10 * 60,
        cb       => sub {
            my $msg   = $self->messageRTC();
            my $count = 0;

            foreach my $coder ( values %{ $self->{coder} } ) {
                $count += 1 if $self->sendUDP( $msg, $coder );
            }
            $self->{log}->info("update RTC on $count hosts");
            $self->{RTCupdate}{last} = localtime( AnyEvent->now )->datetime;
            $self->{RTCupdate}{count} += 1;
        }
    );
} ## end sub launchRTCUpdater

=head3 messageRT()

 Build UECP message of type: RT

=cut

sub messageRT {
    my ( $self, $dsn, $psn, $msg ) = @_;

    # strip message
    $msg = substr( $msg, 0, 64 ) if ( length($msg) > 64 );

    if ( length($msg) == 0 ) {
        return pack(
            "CCCC",
            0x0a,    # Message Element Code
            $dsn,    # Data Set Number
            $psn,    # Programme Service Number
            0,       # Message Element Length
        );

    } else {

        my $mel = length($msg) + 1;
        my $med = 0x01;

        return pack(
            "CCCCCa*",
            0x0a,    # Message Element Code
            $dsn,    # Data Set Number
            $psn,    # Programme Service Number
            $mel,    # Message Element Length
            $med,    # Message Element Data
            $msg
        );
    } ## end else [ if ( length($msg) == 0)]
} ## end sub messageRT

=head3 messageRTC()

Build UECP message of type: RTC

=cut

sub messageRTC {
    my ($self) = @_;
    my $now = AnyEvent->now;

    # this is needed for getting offset
    my $cet = localtime($now);

    # coder time must be in UTC
    my $utc = gmtime($now);
    return pack(
        "C*",
        0x0d,          # Message Element Code
        $utc->yy,      # two digit year
        $utc->mon,     # month
        $utc->mday,    # day on month
        $utc->hour,
        $utc->min,
        $utc->sec,
        0,
        $cet->tzoffset / 1800    # offset in half hour steps
    );
} ## end sub messageRTC

=head3 messageTA()

Build UECP message of type: TA/TP

=cut

sub messageTA {
    my ( $self, $dsn, $psn, $med ) = @_;

    return pack(
        "CCCC",
        03,      # Message Element Code
        $dsn,    # Data Set Number
        $psn,    # Programme Service Number
        $med     # Message Element Data
    );
} ## end sub messageTA

=head3 UECPframe( $data, $crc)

 Build UECP frame with STA STP from $msg. If $crc then also calculate CRC.

=cut

sub UECPframe {
    my ( $self, $msg, $crc ) = @_;
    my $mfl = length($msg);

    my $body = pack(
        "sCCa*",
        0,       # address               2 bytes
        0,       # sequence count        1 byte
        $mfl,    # message field length  1 byte
        $msg     # message               0-255 bytes
    );

    return $body if !$crc;

    my $checksum = crc( $body, 16, 0xffff, 0xffff, 0, 0x1021, 0, 0 );
    return pack(
        "Ca*nC",
        0xfe,    # STA
        $body,
        $checksum,    # the CRC
        0xff          # STP
    );
} ## end sub UECPframe

=head3 sendUDP ( $msg, $coder)

 Send UDP message to $coder.

=cut

sub sendUDP {
    my ( $self, $msg, $coder ) = @_;

    my $conf;
    for ( $coder->{tag} ) {
        /digi/ && do {
            $conf = $self->config->{coderConf}{digi};
            last;
        };
        /2wcom/ && do {
            $conf = $self->config->{coderConf}{'2wcom'};
            last;
        };
        $conf = $self->config->{coderConf}{default};
    } ## end for ( $coder->{tag} )

    my $port    = $conf->{port};
    my $frame   = $self->UECPframe( $msg, $conf->{crc} );
    my $address = sockaddr_in( $port, $coder->{addr} );

    if ( send( UDPPORT, $frame, 0, $address ) ) {
        $self->{status}{count} += 1;
        $self->{status}{last} = localtime( AnyEvent->now )->datetime;
        return 1;
    } else {
        $self->{log}->warn("no data sent: $address");
        return;
    }
} ## end sub sendUDP

=head3 utf2ebu ( $msg)

 Convert $msg in UTF8 encoding to EBU E.1

=cut

sub utf2ebu {
    my ( $self, $msg) = @_;

    # replace various dashes
    $msg =~ s/[\x{2010}-\x{2015}]/-/sg;

    # firt convert to codepage 825
    my $converter = Text::Iconv->new( "UTF-8", "852" );
    $msg = $converter->convert($msg);

    # now we map slovene to EBU E.1
    $msg =~ tr/\xe6\xe7/\xcc\xdc/;    # Šš
    $msg =~ tr/\xac\x9f/\xcb\xdb/;    # Čč
    $msg =~ tr/\xa6\xa7/\xcd\xdd/;    # Žž
    $msg =~ tr/\x8f\x86/\xeb\xfb/;    # Ćć
    $msg =~ tr/\xd1\xd0/\xce\xde/;    # Đđ

    # and the hungarian char
    $msg =~ tr/\x90\x82/\xc2\x82/;    # Éé
    $msg =~ tr/\x8a\x8b/\xa7\xa7/;    # Őő
    $msg =~ tr/\x99\x94/\xd7\x97/;    # Öö
    $msg =~ tr/\x9a\x81/\xd9\x99/;    # Üü
    $msg =~ tr/\xb5\xa0/\xc0\x80/;    # Áá
    $msg =~ tr/\xd6\xa1/\xc4\x84/;    # Íí
    $msg =~ tr/\xe0\xa2/\xc6\x86/;    # Óó
    $msg =~ tr/\xe9\xa3/\xc8\x88/;    # Úú
    $msg =~ tr/\xeb\xfb/\xb7\xb7/;    # Űű

    return $msg;
} ## end sub utf2ebu

=head3 radioText ( )

 Send radiotext data to coders

=cut

sub radioText {
    my ( $self, $response ) = @_;

    my $label = $response->{param}{label};

    # remove xml tags
    $label =~ s|(<[^>]+?>)||g;

    # convert UTF to ASCII TODO do better mapping
    #$label = unidecode($label);
    # convert UTF to EBU 
    $label = $self->utf2ebu($label);

    # walk over onair stations and try to find entry
    my $station;
    for my $s ( values @{ $self->config->{onair} } ) {
        if ( $response->{param}{station} eq $s->{station} ) {
            $station = $s;
            last;
        }
    } ## end for my $s ( values @{ $self...})

    if ( !$station ) {
        $self->{log}->error( "station not valid: " . $response->{param}{station} );
        return;
    }

    # configuration
    my $name = $station->{station};
    my $dsn  = $station->{dsn};
    my $psn  = $station->{psn};

    if ( $dsn && $psn ) {
        my $msg   = $self->messageRT( $dsn, $psn, $label );
        my $count = 0;

        foreach my $coder ( values %{ $self->{coder} } ) {
            if ( $coder->{tag} =~ m|$name| ) {
                $count += 1 if $self->sendUDP( $msg, $coder );
            }
        }
        $self->{log}->info( "RadioText sent to $count hosts - " . $station->{station} );
        return;
    } else {
        $self->{log}->warn( "Missing DSN & PSN - " . $station->{station} );
        return;
    }
} ## end sub radioText

=head3 trafficAnnouncement ( )

 Control TA flag on coders

=cut

sub trafficAnnouncement {
    my ( $self, $response ) = @_;

    my $ta = $response->{param}{flag};
    if ( !defined $ta ) {
        $self->{log}->warn("trafficAnnouncement flag not set");
        return;
    }

    my $count = 0;

    foreach my $coder ( values %{ $self->{coder} } ) {

        my $msg;
        for ( $coder->{tag} ) {
            /prvi/ && do {
                $msg = $self->messageTA( 1, 2, 2 + $ta );
                last;
            };
            /val202/ && do {
                $msg = $self->messageTA( 2, 2, 2 + $ta );
                last;
            };
            /ars/ && do {
                $msg = $self->messageTA( 3, 2, 2 + $ta );
                last;
            };
        } ## end for ( $coder->{tag} )

        if ($msg) {
            $count += 1 if $self->sendUDP( $msg, $coder );
        }
    } ## end foreach my $coder ( values ...)
    $self->{log}->info("trafficAnnouncement sent: $count");
    return;
} ## end sub trafficAnnouncement

=head3 tmcData ( )

 Distribute TMC messages.

=cut

sub tmcData {
    my ( $self, $response ) = @_;

    my $mec = $response->{param}{mec};
    my $msg = $response->{param}{msg};

    if ( $mec == 0x30 or $mec == 0x24 ) {

        # walk over tmc and find provider
        my $tmc;
        for my $t ( values @{ $self->config->{tmc} } ) {
            if ( $response->{param}{provider} eq $t->{provider} ) {
                $tmc = $t;
                last;
            }
        } ## end for my $t ( values @{ $self...})

        if ( !$tmc ) {
            $self->{log}->error("unknown tmc provider");
            return;
        }

        my $count = 0;
        foreach my $coder ( values %{ $self->{coder} } ) {
            my @list    = split( ',', $coder->{tag} );
            my $station = shift @list;

            if ( $tmc->{target} =~ m|$station| ) {
                $count += 1 if $self->sendUDP( $msg, $coder );
            }
        } ## end foreach my $coder ( values ...)
        $self->{log}->trace( "tmc sent to $tmc->{target}: ", $count );
    } else {
        $self->{log}->trace("tmc type not to be forwarded");
        return;
    }
} ## end sub tmcData

1;
